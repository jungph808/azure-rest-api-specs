// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace SecurityInsights
{
    /// <summary> The Metadata service client. </summary>
    public partial class MetadataClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential;
        private static readonly string[] AuthorizationScopes0 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential0;
        private static readonly string[] AuthorizationScopes1 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential1;
        private static readonly string[] AuthorizationScopes2 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential2;
        private static readonly string[] AuthorizationScopes3 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential3;
        private static readonly string[] AuthorizationScopes4 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential4;
        private static readonly string[] AuthorizationScopes5 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential5;
        private static readonly string[] AuthorizationScopes6 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential6;
        private static readonly string[] AuthorizationScopes7 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential7;
        private static readonly string[] AuthorizationScopes8 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential8;
        private static readonly string[] AuthorizationScopes9 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential9;
        private static readonly string[] AuthorizationScopes10 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential10;
        private static readonly string[] AuthorizationScopes11 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential11;
        private static readonly string[] AuthorizationScopes12 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential12;
        private static readonly string[] AuthorizationScopes13 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential13;
        private static readonly string[] AuthorizationScopes14 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential14;
        private static readonly string[] AuthorizationScopes15 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential15;
        private static readonly string[] AuthorizationScopes16 = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential16;
        private readonly HttpPipeline _pipeline;
        private readonly string _subscriptionId;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of MetadataClient for mocking. </summary>
        protected MetadataClient()
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential) : this(subscriptionId, credential, new Uri("https://management.azure.com"), new SecurityInsightsClientOptions())
        {
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of MetadataClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="credential"/> or <paramref name="endpoint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public MetadataClient(string subscriptionId, TokenCredential credential, Uri endpoint, SecurityInsightsClientOptions options)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            options ??= new SecurityInsightsClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential16 = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential16, AuthorizationScopes16) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Get a Metadata. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="workspaceName"> The name of the workspace. </param>
        /// <param name="metadataName"> The Metadata name. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/> or <paramref name="metadataName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/> or <paramref name="metadataName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>MetadataModel</c>:
        /// <code>{
        ///   etag: string, # Optional. Etag of the azure resource
        ///   id: string, # Optional. Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ///   name: string, # Optional. The name of the resource
        ///   type: string, # Optional. The type of the resource. E.g. &quot;Microsoft.Compute/virtualMachines&quot; or &quot;Microsoft.Storage/storageAccounts&quot;
        ///   systemData: {
        ///     createdBy: string, # Optional. The identity that created the resource.
        ///     createdByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that created the resource.
        ///     createdAt: string (ISO 8601 Format), # Optional. The timestamp of resource creation (UTC).
        ///     lastModifiedBy: string, # Optional. The identity that last modified the resource.
        ///     lastModifiedByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that last modified the resource.
        ///     lastModifiedAt: string (ISO 8601 Format), # Optional. The timestamp of resource last modification (UTC)
        ///   }, # Optional. Azure Resource Manager metadata containing createdBy and modifiedBy information.
        ///   properties: {
        ///     contentId: string, # Optional. Static ID for the content.  Used to identify dependencies and content from solutions or community.  Hard-coded/static for out of the box content and solutions. Dynamic for user-created.  This is the resource name
        ///     parentId: string, # Required. Full parent resource ID of the content item the metadata is for.  This is the full resource ID including the scope (subscription and resource group)
        ///     version: string, # Optional. Version of the content.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM template best practices.  Can also be any string, but then we cannot guarantee any version checks
        ///     kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Required. The kind of content the metadata is for.
        ///     source: {
        ///       kind: &quot;LocalWorkspace&quot; | &quot;Community&quot; | &quot;Solution&quot; | &quot;SourceRepository&quot;, # Required. Source type of the content
        ///       name: string, # Optional. Name of the content source.  The repo name, solution name, LA workspace name etc.
        ///       sourceId: string, # Optional. ID of the content source.  The solution ID, workspace ID, etc
        ///     }, # Optional. Source of the content.  This is where/how it was created.
        ///     author: {
        ///       name: string, # Optional. Name of the author. Company or person.
        ///       email: string, # Optional. Email of author contact
        ///       link: string, # Optional. Link for author/vendor page
        ///     }, # Optional. The creator of the content item.
        ///     support: {
        ///       tier: &quot;Microsoft&quot; | &quot;Partner&quot; | &quot;Community&quot;, # Required. Type of support for content item
        ///       name: string, # Optional. Name of the support contact. Company or person.
        ///       email: string, # Optional. Email of support contact
        ///       link: string, # Optional. Link for support help, like to support page to open a ticket etc.
        ///     }, # Optional. Support information for the metadata - type, name, contact information
        ///     dependencies: {
        ///       contentId: string, # Optional. Id of the content item we depend on
        ///       kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Optional. Type of the content item we depend on
        ///       version: string, # Optional. Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        ///       name: string, # Optional. Name of the content item
        ///       operator: &quot;AND&quot; | &quot;OR&quot;, # Optional. Operator used for list of dependencies in criteria array.
        ///       criteria: [MetadataDependencies], # Optional. This is the list of dependencies we must fulfill, according to the AND/OR operator
        ///     }, # Optional. Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex formats.
        ///     categories: {
        ///       domains: [string], # Optional. domain for the solution content item
        ///       verticals: [string], # Optional. Industry verticals for the solution content item
        ///     }, # Optional. Categories for the solution content item
        ///     providers: [string], # Optional. Providers for the solution content item
        ///     firstPublishDate: FirstPublishDate, # Optional. first publish date solution content item
        ///     lastPublishDate: LastPublishDate, # Optional. last publish date for the solution content item
        ///     customVersion: string, # Optional. The custom version of the content. A optional free text
        ///     contentSchemaVersion: string, # Optional. Schema version of the content. Can be used to distinguish between different flow based on the schema version
        ///     icon: string, # Optional. the icon identifier. this id can later be fetched from the solution template
        ///     threatAnalysisTactics: [string], # Optional. the tactics the resource covers
        ///     threatAnalysisTechniques: [string], # Optional. the techniques the resource covers, these have to be aligned with the tactics being used
        ///     previewImages: [string], # Optional. preview image file names. These will be taken from the solution artifacts
        ///     previewImagesDark: [string], # Optional. preview image file names. These will be taken from the solution artifacts. used for dark theme support
        ///   }, # Optional. Metadata properties
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetMetadataAsync(string resourceGroupName, string workspaceName, string metadataName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(workspaceName, nameof(workspaceName));
            Argument.AssertNotNullOrEmpty(metadataName, nameof(metadataName));

            using var scope = ClientDiagnostics.CreateScope("MetadataClient.GetMetadata");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMetadataRequest(resourceGroupName, workspaceName, metadataName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a Metadata. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="workspaceName"> The name of the workspace. </param>
        /// <param name="metadataName"> The Metadata name. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/> or <paramref name="metadataName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/> or <paramref name="metadataName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>MetadataModel</c>:
        /// <code>{
        ///   etag: string, # Optional. Etag of the azure resource
        ///   id: string, # Optional. Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ///   name: string, # Optional. The name of the resource
        ///   type: string, # Optional. The type of the resource. E.g. &quot;Microsoft.Compute/virtualMachines&quot; or &quot;Microsoft.Storage/storageAccounts&quot;
        ///   systemData: {
        ///     createdBy: string, # Optional. The identity that created the resource.
        ///     createdByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that created the resource.
        ///     createdAt: string (ISO 8601 Format), # Optional. The timestamp of resource creation (UTC).
        ///     lastModifiedBy: string, # Optional. The identity that last modified the resource.
        ///     lastModifiedByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that last modified the resource.
        ///     lastModifiedAt: string (ISO 8601 Format), # Optional. The timestamp of resource last modification (UTC)
        ///   }, # Optional. Azure Resource Manager metadata containing createdBy and modifiedBy information.
        ///   properties: {
        ///     contentId: string, # Optional. Static ID for the content.  Used to identify dependencies and content from solutions or community.  Hard-coded/static for out of the box content and solutions. Dynamic for user-created.  This is the resource name
        ///     parentId: string, # Required. Full parent resource ID of the content item the metadata is for.  This is the full resource ID including the scope (subscription and resource group)
        ///     version: string, # Optional. Version of the content.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM template best practices.  Can also be any string, but then we cannot guarantee any version checks
        ///     kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Required. The kind of content the metadata is for.
        ///     source: {
        ///       kind: &quot;LocalWorkspace&quot; | &quot;Community&quot; | &quot;Solution&quot; | &quot;SourceRepository&quot;, # Required. Source type of the content
        ///       name: string, # Optional. Name of the content source.  The repo name, solution name, LA workspace name etc.
        ///       sourceId: string, # Optional. ID of the content source.  The solution ID, workspace ID, etc
        ///     }, # Optional. Source of the content.  This is where/how it was created.
        ///     author: {
        ///       name: string, # Optional. Name of the author. Company or person.
        ///       email: string, # Optional. Email of author contact
        ///       link: string, # Optional. Link for author/vendor page
        ///     }, # Optional. The creator of the content item.
        ///     support: {
        ///       tier: &quot;Microsoft&quot; | &quot;Partner&quot; | &quot;Community&quot;, # Required. Type of support for content item
        ///       name: string, # Optional. Name of the support contact. Company or person.
        ///       email: string, # Optional. Email of support contact
        ///       link: string, # Optional. Link for support help, like to support page to open a ticket etc.
        ///     }, # Optional. Support information for the metadata - type, name, contact information
        ///     dependencies: {
        ///       contentId: string, # Optional. Id of the content item we depend on
        ///       kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Optional. Type of the content item we depend on
        ///       version: string, # Optional. Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        ///       name: string, # Optional. Name of the content item
        ///       operator: &quot;AND&quot; | &quot;OR&quot;, # Optional. Operator used for list of dependencies in criteria array.
        ///       criteria: [MetadataDependencies], # Optional. This is the list of dependencies we must fulfill, according to the AND/OR operator
        ///     }, # Optional. Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex formats.
        ///     categories: {
        ///       domains: [string], # Optional. domain for the solution content item
        ///       verticals: [string], # Optional. Industry verticals for the solution content item
        ///     }, # Optional. Categories for the solution content item
        ///     providers: [string], # Optional. Providers for the solution content item
        ///     firstPublishDate: FirstPublishDate, # Optional. first publish date solution content item
        ///     lastPublishDate: LastPublishDate, # Optional. last publish date for the solution content item
        ///     customVersion: string, # Optional. The custom version of the content. A optional free text
        ///     contentSchemaVersion: string, # Optional. Schema version of the content. Can be used to distinguish between different flow based on the schema version
        ///     icon: string, # Optional. the icon identifier. this id can later be fetched from the solution template
        ///     threatAnalysisTactics: [string], # Optional. the tactics the resource covers
        ///     threatAnalysisTechniques: [string], # Optional. the techniques the resource covers, these have to be aligned with the tactics being used
        ///     previewImages: [string], # Optional. preview image file names. These will be taken from the solution artifacts
        ///     previewImagesDark: [string], # Optional. preview image file names. These will be taken from the solution artifacts. used for dark theme support
        ///   }, # Optional. Metadata properties
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetMetadata(string resourceGroupName, string workspaceName, string metadataName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(workspaceName, nameof(workspaceName));
            Argument.AssertNotNullOrEmpty(metadataName, nameof(metadataName));

            using var scope = ClientDiagnostics.CreateScope("MetadataClient.GetMetadata");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMetadataRequest(resourceGroupName, workspaceName, metadataName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a Metadata. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="workspaceName"> The name of the workspace. </param>
        /// <param name="metadataName"> The Metadata name. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/> or <paramref name="metadataName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/> or <paramref name="metadataName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteAsync(string resourceGroupName, string workspaceName, string metadataName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(workspaceName, nameof(workspaceName));
            Argument.AssertNotNullOrEmpty(metadataName, nameof(metadataName));

            using var scope = ClientDiagnostics.CreateScope("MetadataClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(resourceGroupName, workspaceName, metadataName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a Metadata. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="workspaceName"> The name of the workspace. </param>
        /// <param name="metadataName"> The Metadata name. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/> or <paramref name="metadataName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/> or <paramref name="metadataName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response Delete(string resourceGroupName, string workspaceName, string metadataName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(workspaceName, nameof(workspaceName));
            Argument.AssertNotNullOrEmpty(metadataName, nameof(metadataName));

            using var scope = ClientDiagnostics.CreateScope("MetadataClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(resourceGroupName, workspaceName, metadataName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a Metadata. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="workspaceName"> The name of the workspace. </param>
        /// <param name="metadataName"> The Metadata name. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/>, <paramref name="metadataName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/> or <paramref name="metadataName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>MetadataModel</c>:
        /// <code>{
        ///   etag: string, # Optional. Etag of the azure resource
        ///   id: string, # Optional. Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ///   name: string, # Optional. The name of the resource
        ///   type: string, # Optional. The type of the resource. E.g. &quot;Microsoft.Compute/virtualMachines&quot; or &quot;Microsoft.Storage/storageAccounts&quot;
        ///   systemData: {
        ///     createdBy: string, # Optional. The identity that created the resource.
        ///     createdByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that created the resource.
        ///     createdAt: string (ISO 8601 Format), # Optional. The timestamp of resource creation (UTC).
        ///     lastModifiedBy: string, # Optional. The identity that last modified the resource.
        ///     lastModifiedByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that last modified the resource.
        ///     lastModifiedAt: string (ISO 8601 Format), # Optional. The timestamp of resource last modification (UTC)
        ///   }, # Optional. Azure Resource Manager metadata containing createdBy and modifiedBy information.
        ///   properties: {
        ///     contentId: string, # Optional. Static ID for the content.  Used to identify dependencies and content from solutions or community.  Hard-coded/static for out of the box content and solutions. Dynamic for user-created.  This is the resource name
        ///     parentId: string, # Required. Full parent resource ID of the content item the metadata is for.  This is the full resource ID including the scope (subscription and resource group)
        ///     version: string, # Optional. Version of the content.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM template best practices.  Can also be any string, but then we cannot guarantee any version checks
        ///     kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Required. The kind of content the metadata is for.
        ///     source: {
        ///       kind: &quot;LocalWorkspace&quot; | &quot;Community&quot; | &quot;Solution&quot; | &quot;SourceRepository&quot;, # Required. Source type of the content
        ///       name: string, # Optional. Name of the content source.  The repo name, solution name, LA workspace name etc.
        ///       sourceId: string, # Optional. ID of the content source.  The solution ID, workspace ID, etc
        ///     }, # Optional. Source of the content.  This is where/how it was created.
        ///     author: {
        ///       name: string, # Optional. Name of the author. Company or person.
        ///       email: string, # Optional. Email of author contact
        ///       link: string, # Optional. Link for author/vendor page
        ///     }, # Optional. The creator of the content item.
        ///     support: {
        ///       tier: &quot;Microsoft&quot; | &quot;Partner&quot; | &quot;Community&quot;, # Required. Type of support for content item
        ///       name: string, # Optional. Name of the support contact. Company or person.
        ///       email: string, # Optional. Email of support contact
        ///       link: string, # Optional. Link for support help, like to support page to open a ticket etc.
        ///     }, # Optional. Support information for the metadata - type, name, contact information
        ///     dependencies: {
        ///       contentId: string, # Optional. Id of the content item we depend on
        ///       kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Optional. Type of the content item we depend on
        ///       version: string, # Optional. Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        ///       name: string, # Optional. Name of the content item
        ///       operator: &quot;AND&quot; | &quot;OR&quot;, # Optional. Operator used for list of dependencies in criteria array.
        ///       criteria: [MetadataDependencies], # Optional. This is the list of dependencies we must fulfill, according to the AND/OR operator
        ///     }, # Optional. Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex formats.
        ///     categories: {
        ///       domains: [string], # Optional. domain for the solution content item
        ///       verticals: [string], # Optional. Industry verticals for the solution content item
        ///     }, # Optional. Categories for the solution content item
        ///     providers: [string], # Optional. Providers for the solution content item
        ///     firstPublishDate: FirstPublishDate, # Optional. first publish date solution content item
        ///     lastPublishDate: LastPublishDate, # Optional. last publish date for the solution content item
        ///     customVersion: string, # Optional. The custom version of the content. A optional free text
        ///     contentSchemaVersion: string, # Optional. Schema version of the content. Can be used to distinguish between different flow based on the schema version
        ///     icon: string, # Optional. the icon identifier. this id can later be fetched from the solution template
        ///     threatAnalysisTactics: [string], # Optional. the tactics the resource covers
        ///     threatAnalysisTechniques: [string], # Optional. the techniques the resource covers, these have to be aligned with the tactics being used
        ///     previewImages: [string], # Optional. preview image file names. These will be taken from the solution artifacts
        ///     previewImagesDark: [string], # Optional. preview image file names. These will be taken from the solution artifacts. used for dark theme support
        ///   }, # Optional. Metadata properties
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>MetadataModel</c>:
        /// <code>{
        ///   etag: string, # Optional. Etag of the azure resource
        ///   id: string, # Optional. Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ///   name: string, # Optional. The name of the resource
        ///   type: string, # Optional. The type of the resource. E.g. &quot;Microsoft.Compute/virtualMachines&quot; or &quot;Microsoft.Storage/storageAccounts&quot;
        ///   systemData: {
        ///     createdBy: string, # Optional. The identity that created the resource.
        ///     createdByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that created the resource.
        ///     createdAt: string (ISO 8601 Format), # Optional. The timestamp of resource creation (UTC).
        ///     lastModifiedBy: string, # Optional. The identity that last modified the resource.
        ///     lastModifiedByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that last modified the resource.
        ///     lastModifiedAt: string (ISO 8601 Format), # Optional. The timestamp of resource last modification (UTC)
        ///   }, # Optional. Azure Resource Manager metadata containing createdBy and modifiedBy information.
        ///   properties: {
        ///     contentId: string, # Optional. Static ID for the content.  Used to identify dependencies and content from solutions or community.  Hard-coded/static for out of the box content and solutions. Dynamic for user-created.  This is the resource name
        ///     parentId: string, # Required. Full parent resource ID of the content item the metadata is for.  This is the full resource ID including the scope (subscription and resource group)
        ///     version: string, # Optional. Version of the content.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM template best practices.  Can also be any string, but then we cannot guarantee any version checks
        ///     kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Required. The kind of content the metadata is for.
        ///     source: {
        ///       kind: &quot;LocalWorkspace&quot; | &quot;Community&quot; | &quot;Solution&quot; | &quot;SourceRepository&quot;, # Required. Source type of the content
        ///       name: string, # Optional. Name of the content source.  The repo name, solution name, LA workspace name etc.
        ///       sourceId: string, # Optional. ID of the content source.  The solution ID, workspace ID, etc
        ///     }, # Optional. Source of the content.  This is where/how it was created.
        ///     author: {
        ///       name: string, # Optional. Name of the author. Company or person.
        ///       email: string, # Optional. Email of author contact
        ///       link: string, # Optional. Link for author/vendor page
        ///     }, # Optional. The creator of the content item.
        ///     support: {
        ///       tier: &quot;Microsoft&quot; | &quot;Partner&quot; | &quot;Community&quot;, # Required. Type of support for content item
        ///       name: string, # Optional. Name of the support contact. Company or person.
        ///       email: string, # Optional. Email of support contact
        ///       link: string, # Optional. Link for support help, like to support page to open a ticket etc.
        ///     }, # Optional. Support information for the metadata - type, name, contact information
        ///     dependencies: {
        ///       contentId: string, # Optional. Id of the content item we depend on
        ///       kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Optional. Type of the content item we depend on
        ///       version: string, # Optional. Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        ///       name: string, # Optional. Name of the content item
        ///       operator: &quot;AND&quot; | &quot;OR&quot;, # Optional. Operator used for list of dependencies in criteria array.
        ///       criteria: [MetadataDependencies], # Optional. This is the list of dependencies we must fulfill, according to the AND/OR operator
        ///     }, # Optional. Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex formats.
        ///     categories: {
        ///       domains: [string], # Optional. domain for the solution content item
        ///       verticals: [string], # Optional. Industry verticals for the solution content item
        ///     }, # Optional. Categories for the solution content item
        ///     providers: [string], # Optional. Providers for the solution content item
        ///     firstPublishDate: FirstPublishDate, # Optional. first publish date solution content item
        ///     lastPublishDate: LastPublishDate, # Optional. last publish date for the solution content item
        ///     customVersion: string, # Optional. The custom version of the content. A optional free text
        ///     contentSchemaVersion: string, # Optional. Schema version of the content. Can be used to distinguish between different flow based on the schema version
        ///     icon: string, # Optional. the icon identifier. this id can later be fetched from the solution template
        ///     threatAnalysisTactics: [string], # Optional. the tactics the resource covers
        ///     threatAnalysisTechniques: [string], # Optional. the techniques the resource covers, these have to be aligned with the tactics being used
        ///     previewImages: [string], # Optional. preview image file names. These will be taken from the solution artifacts
        ///     previewImagesDark: [string], # Optional. preview image file names. These will be taken from the solution artifacts. used for dark theme support
        ///   }, # Optional. Metadata properties
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateAsync(string resourceGroupName, string workspaceName, string metadataName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(workspaceName, nameof(workspaceName));
            Argument.AssertNotNullOrEmpty(metadataName, nameof(metadataName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("MetadataClient.Create");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateRequest(resourceGroupName, workspaceName, metadataName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a Metadata. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="workspaceName"> The name of the workspace. </param>
        /// <param name="metadataName"> The Metadata name. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/>, <paramref name="metadataName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/> or <paramref name="metadataName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>MetadataModel</c>:
        /// <code>{
        ///   etag: string, # Optional. Etag of the azure resource
        ///   id: string, # Optional. Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ///   name: string, # Optional. The name of the resource
        ///   type: string, # Optional. The type of the resource. E.g. &quot;Microsoft.Compute/virtualMachines&quot; or &quot;Microsoft.Storage/storageAccounts&quot;
        ///   systemData: {
        ///     createdBy: string, # Optional. The identity that created the resource.
        ///     createdByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that created the resource.
        ///     createdAt: string (ISO 8601 Format), # Optional. The timestamp of resource creation (UTC).
        ///     lastModifiedBy: string, # Optional. The identity that last modified the resource.
        ///     lastModifiedByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that last modified the resource.
        ///     lastModifiedAt: string (ISO 8601 Format), # Optional. The timestamp of resource last modification (UTC)
        ///   }, # Optional. Azure Resource Manager metadata containing createdBy and modifiedBy information.
        ///   properties: {
        ///     contentId: string, # Optional. Static ID for the content.  Used to identify dependencies and content from solutions or community.  Hard-coded/static for out of the box content and solutions. Dynamic for user-created.  This is the resource name
        ///     parentId: string, # Required. Full parent resource ID of the content item the metadata is for.  This is the full resource ID including the scope (subscription and resource group)
        ///     version: string, # Optional. Version of the content.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM template best practices.  Can also be any string, but then we cannot guarantee any version checks
        ///     kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Required. The kind of content the metadata is for.
        ///     source: {
        ///       kind: &quot;LocalWorkspace&quot; | &quot;Community&quot; | &quot;Solution&quot; | &quot;SourceRepository&quot;, # Required. Source type of the content
        ///       name: string, # Optional. Name of the content source.  The repo name, solution name, LA workspace name etc.
        ///       sourceId: string, # Optional. ID of the content source.  The solution ID, workspace ID, etc
        ///     }, # Optional. Source of the content.  This is where/how it was created.
        ///     author: {
        ///       name: string, # Optional. Name of the author. Company or person.
        ///       email: string, # Optional. Email of author contact
        ///       link: string, # Optional. Link for author/vendor page
        ///     }, # Optional. The creator of the content item.
        ///     support: {
        ///       tier: &quot;Microsoft&quot; | &quot;Partner&quot; | &quot;Community&quot;, # Required. Type of support for content item
        ///       name: string, # Optional. Name of the support contact. Company or person.
        ///       email: string, # Optional. Email of support contact
        ///       link: string, # Optional. Link for support help, like to support page to open a ticket etc.
        ///     }, # Optional. Support information for the metadata - type, name, contact information
        ///     dependencies: {
        ///       contentId: string, # Optional. Id of the content item we depend on
        ///       kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Optional. Type of the content item we depend on
        ///       version: string, # Optional. Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        ///       name: string, # Optional. Name of the content item
        ///       operator: &quot;AND&quot; | &quot;OR&quot;, # Optional. Operator used for list of dependencies in criteria array.
        ///       criteria: [MetadataDependencies], # Optional. This is the list of dependencies we must fulfill, according to the AND/OR operator
        ///     }, # Optional. Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex formats.
        ///     categories: {
        ///       domains: [string], # Optional. domain for the solution content item
        ///       verticals: [string], # Optional. Industry verticals for the solution content item
        ///     }, # Optional. Categories for the solution content item
        ///     providers: [string], # Optional. Providers for the solution content item
        ///     firstPublishDate: FirstPublishDate, # Optional. first publish date solution content item
        ///     lastPublishDate: LastPublishDate, # Optional. last publish date for the solution content item
        ///     customVersion: string, # Optional. The custom version of the content. A optional free text
        ///     contentSchemaVersion: string, # Optional. Schema version of the content. Can be used to distinguish between different flow based on the schema version
        ///     icon: string, # Optional. the icon identifier. this id can later be fetched from the solution template
        ///     threatAnalysisTactics: [string], # Optional. the tactics the resource covers
        ///     threatAnalysisTechniques: [string], # Optional. the techniques the resource covers, these have to be aligned with the tactics being used
        ///     previewImages: [string], # Optional. preview image file names. These will be taken from the solution artifacts
        ///     previewImagesDark: [string], # Optional. preview image file names. These will be taken from the solution artifacts. used for dark theme support
        ///   }, # Optional. Metadata properties
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>MetadataModel</c>:
        /// <code>{
        ///   etag: string, # Optional. Etag of the azure resource
        ///   id: string, # Optional. Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ///   name: string, # Optional. The name of the resource
        ///   type: string, # Optional. The type of the resource. E.g. &quot;Microsoft.Compute/virtualMachines&quot; or &quot;Microsoft.Storage/storageAccounts&quot;
        ///   systemData: {
        ///     createdBy: string, # Optional. The identity that created the resource.
        ///     createdByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that created the resource.
        ///     createdAt: string (ISO 8601 Format), # Optional. The timestamp of resource creation (UTC).
        ///     lastModifiedBy: string, # Optional. The identity that last modified the resource.
        ///     lastModifiedByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that last modified the resource.
        ///     lastModifiedAt: string (ISO 8601 Format), # Optional. The timestamp of resource last modification (UTC)
        ///   }, # Optional. Azure Resource Manager metadata containing createdBy and modifiedBy information.
        ///   properties: {
        ///     contentId: string, # Optional. Static ID for the content.  Used to identify dependencies and content from solutions or community.  Hard-coded/static for out of the box content and solutions. Dynamic for user-created.  This is the resource name
        ///     parentId: string, # Required. Full parent resource ID of the content item the metadata is for.  This is the full resource ID including the scope (subscription and resource group)
        ///     version: string, # Optional. Version of the content.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM template best practices.  Can also be any string, but then we cannot guarantee any version checks
        ///     kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Required. The kind of content the metadata is for.
        ///     source: {
        ///       kind: &quot;LocalWorkspace&quot; | &quot;Community&quot; | &quot;Solution&quot; | &quot;SourceRepository&quot;, # Required. Source type of the content
        ///       name: string, # Optional. Name of the content source.  The repo name, solution name, LA workspace name etc.
        ///       sourceId: string, # Optional. ID of the content source.  The solution ID, workspace ID, etc
        ///     }, # Optional. Source of the content.  This is where/how it was created.
        ///     author: {
        ///       name: string, # Optional. Name of the author. Company or person.
        ///       email: string, # Optional. Email of author contact
        ///       link: string, # Optional. Link for author/vendor page
        ///     }, # Optional. The creator of the content item.
        ///     support: {
        ///       tier: &quot;Microsoft&quot; | &quot;Partner&quot; | &quot;Community&quot;, # Required. Type of support for content item
        ///       name: string, # Optional. Name of the support contact. Company or person.
        ///       email: string, # Optional. Email of support contact
        ///       link: string, # Optional. Link for support help, like to support page to open a ticket etc.
        ///     }, # Optional. Support information for the metadata - type, name, contact information
        ///     dependencies: {
        ///       contentId: string, # Optional. Id of the content item we depend on
        ///       kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Optional. Type of the content item we depend on
        ///       version: string, # Optional. Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        ///       name: string, # Optional. Name of the content item
        ///       operator: &quot;AND&quot; | &quot;OR&quot;, # Optional. Operator used for list of dependencies in criteria array.
        ///       criteria: [MetadataDependencies], # Optional. This is the list of dependencies we must fulfill, according to the AND/OR operator
        ///     }, # Optional. Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex formats.
        ///     categories: {
        ///       domains: [string], # Optional. domain for the solution content item
        ///       verticals: [string], # Optional. Industry verticals for the solution content item
        ///     }, # Optional. Categories for the solution content item
        ///     providers: [string], # Optional. Providers for the solution content item
        ///     firstPublishDate: FirstPublishDate, # Optional. first publish date solution content item
        ///     lastPublishDate: LastPublishDate, # Optional. last publish date for the solution content item
        ///     customVersion: string, # Optional. The custom version of the content. A optional free text
        ///     contentSchemaVersion: string, # Optional. Schema version of the content. Can be used to distinguish between different flow based on the schema version
        ///     icon: string, # Optional. the icon identifier. this id can later be fetched from the solution template
        ///     threatAnalysisTactics: [string], # Optional. the tactics the resource covers
        ///     threatAnalysisTechniques: [string], # Optional. the techniques the resource covers, these have to be aligned with the tactics being used
        ///     previewImages: [string], # Optional. preview image file names. These will be taken from the solution artifacts
        ///     previewImagesDark: [string], # Optional. preview image file names. These will be taken from the solution artifacts. used for dark theme support
        ///   }, # Optional. Metadata properties
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Create(string resourceGroupName, string workspaceName, string metadataName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(workspaceName, nameof(workspaceName));
            Argument.AssertNotNullOrEmpty(metadataName, nameof(metadataName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("MetadataClient.Create");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateRequest(resourceGroupName, workspaceName, metadataName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update an existing Metadata. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="workspaceName"> The name of the workspace. </param>
        /// <param name="metadataName"> The Metadata name. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/>, <paramref name="metadataName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/> or <paramref name="metadataName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>MetadataPatch</c>:
        /// <code>{
        ///   etag: string, # Optional. Etag of the azure resource
        ///   id: string, # Optional. Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ///   name: string, # Optional. The name of the resource
        ///   type: string, # Optional. The type of the resource. E.g. &quot;Microsoft.Compute/virtualMachines&quot; or &quot;Microsoft.Storage/storageAccounts&quot;
        ///   systemData: {
        ///     createdBy: string, # Optional. The identity that created the resource.
        ///     createdByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that created the resource.
        ///     createdAt: string (ISO 8601 Format), # Optional. The timestamp of resource creation (UTC).
        ///     lastModifiedBy: string, # Optional. The identity that last modified the resource.
        ///     lastModifiedByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that last modified the resource.
        ///     lastModifiedAt: string (ISO 8601 Format), # Optional. The timestamp of resource last modification (UTC)
        ///   }, # Optional. Azure Resource Manager metadata containing createdBy and modifiedBy information.
        ///   properties: {
        ///     contentId: string, # Optional. Static ID for the content.  Used to identify dependencies and content from solutions or community.  Hard-coded/static for out of the box content and solutions. Dynamic for user-created.  This is the resource name
        ///     parentId: string, # Optional. Full parent resource ID of the content item the metadata is for.  This is the full resource ID including the scope (subscription and resource group)
        ///     version: string, # Optional. Version of the content.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM template best practices.  Can also be any string, but then we cannot guarantee any version checks
        ///     kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Optional. The kind of content the metadata is for.
        ///     source: {
        ///       kind: &quot;LocalWorkspace&quot; | &quot;Community&quot; | &quot;Solution&quot; | &quot;SourceRepository&quot;, # Required. Source type of the content
        ///       name: string, # Optional. Name of the content source.  The repo name, solution name, LA workspace name etc.
        ///       sourceId: string, # Optional. ID of the content source.  The solution ID, workspace ID, etc
        ///     }, # Optional. Source of the content.  This is where/how it was created.
        ///     author: {
        ///       name: string, # Optional. Name of the author. Company or person.
        ///       email: string, # Optional. Email of author contact
        ///       link: string, # Optional. Link for author/vendor page
        ///     }, # Optional. The creator of the content item.
        ///     support: {
        ///       tier: &quot;Microsoft&quot; | &quot;Partner&quot; | &quot;Community&quot;, # Required. Type of support for content item
        ///       name: string, # Optional. Name of the support contact. Company or person.
        ///       email: string, # Optional. Email of support contact
        ///       link: string, # Optional. Link for support help, like to support page to open a ticket etc.
        ///     }, # Optional. Support information for the metadata - type, name, contact information
        ///     dependencies: {
        ///       contentId: string, # Optional. Id of the content item we depend on
        ///       kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Optional. Type of the content item we depend on
        ///       version: string, # Optional. Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        ///       name: string, # Optional. Name of the content item
        ///       operator: &quot;AND&quot; | &quot;OR&quot;, # Optional. Operator used for list of dependencies in criteria array.
        ///       criteria: [MetadataDependencies], # Optional. This is the list of dependencies we must fulfill, according to the AND/OR operator
        ///     }, # Optional. Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex formats.
        ///     categories: {
        ///       domains: [string], # Optional. domain for the solution content item
        ///       verticals: [string], # Optional. Industry verticals for the solution content item
        ///     }, # Optional. Categories for the solution content item
        ///     providers: [string], # Optional. Providers for the solution content item
        ///     firstPublishDate: FirstPublishDate, # Optional. first publish date solution content item
        ///     lastPublishDate: LastPublishDate, # Optional. last publish date for the solution content item
        ///     customVersion: string, # Optional. The custom version of the content. A optional free text
        ///     contentSchemaVersion: string, # Optional. Schema version of the content. Can be used to distinguish between different flow based on the schema version
        ///     icon: string, # Optional. the icon identifier. this id can later be fetched from the solution template
        ///     threatAnalysisTactics: [string], # Optional. the tactics the resource covers
        ///     threatAnalysisTechniques: [string], # Optional. the techniques the resource covers, these have to be aligned with the tactics being used
        ///     previewImages: [string], # Optional. preview image file names. These will be taken from the solution artifacts
        ///     previewImagesDark: [string], # Optional. preview image file names. These will be taken from the solution artifacts. used for dark theme support
        ///   }, # Optional. Metadata patch request body
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>MetadataModel</c>:
        /// <code>{
        ///   etag: string, # Optional. Etag of the azure resource
        ///   id: string, # Optional. Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ///   name: string, # Optional. The name of the resource
        ///   type: string, # Optional. The type of the resource. E.g. &quot;Microsoft.Compute/virtualMachines&quot; or &quot;Microsoft.Storage/storageAccounts&quot;
        ///   systemData: {
        ///     createdBy: string, # Optional. The identity that created the resource.
        ///     createdByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that created the resource.
        ///     createdAt: string (ISO 8601 Format), # Optional. The timestamp of resource creation (UTC).
        ///     lastModifiedBy: string, # Optional. The identity that last modified the resource.
        ///     lastModifiedByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that last modified the resource.
        ///     lastModifiedAt: string (ISO 8601 Format), # Optional. The timestamp of resource last modification (UTC)
        ///   }, # Optional. Azure Resource Manager metadata containing createdBy and modifiedBy information.
        ///   properties: {
        ///     contentId: string, # Optional. Static ID for the content.  Used to identify dependencies and content from solutions or community.  Hard-coded/static for out of the box content and solutions. Dynamic for user-created.  This is the resource name
        ///     parentId: string, # Required. Full parent resource ID of the content item the metadata is for.  This is the full resource ID including the scope (subscription and resource group)
        ///     version: string, # Optional. Version of the content.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM template best practices.  Can also be any string, but then we cannot guarantee any version checks
        ///     kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Required. The kind of content the metadata is for.
        ///     source: {
        ///       kind: &quot;LocalWorkspace&quot; | &quot;Community&quot; | &quot;Solution&quot; | &quot;SourceRepository&quot;, # Required. Source type of the content
        ///       name: string, # Optional. Name of the content source.  The repo name, solution name, LA workspace name etc.
        ///       sourceId: string, # Optional. ID of the content source.  The solution ID, workspace ID, etc
        ///     }, # Optional. Source of the content.  This is where/how it was created.
        ///     author: {
        ///       name: string, # Optional. Name of the author. Company or person.
        ///       email: string, # Optional. Email of author contact
        ///       link: string, # Optional. Link for author/vendor page
        ///     }, # Optional. The creator of the content item.
        ///     support: {
        ///       tier: &quot;Microsoft&quot; | &quot;Partner&quot; | &quot;Community&quot;, # Required. Type of support for content item
        ///       name: string, # Optional. Name of the support contact. Company or person.
        ///       email: string, # Optional. Email of support contact
        ///       link: string, # Optional. Link for support help, like to support page to open a ticket etc.
        ///     }, # Optional. Support information for the metadata - type, name, contact information
        ///     dependencies: {
        ///       contentId: string, # Optional. Id of the content item we depend on
        ///       kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Optional. Type of the content item we depend on
        ///       version: string, # Optional. Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        ///       name: string, # Optional. Name of the content item
        ///       operator: &quot;AND&quot; | &quot;OR&quot;, # Optional. Operator used for list of dependencies in criteria array.
        ///       criteria: [MetadataDependencies], # Optional. This is the list of dependencies we must fulfill, according to the AND/OR operator
        ///     }, # Optional. Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex formats.
        ///     categories: {
        ///       domains: [string], # Optional. domain for the solution content item
        ///       verticals: [string], # Optional. Industry verticals for the solution content item
        ///     }, # Optional. Categories for the solution content item
        ///     providers: [string], # Optional. Providers for the solution content item
        ///     firstPublishDate: FirstPublishDate, # Optional. first publish date solution content item
        ///     lastPublishDate: LastPublishDate, # Optional. last publish date for the solution content item
        ///     customVersion: string, # Optional. The custom version of the content. A optional free text
        ///     contentSchemaVersion: string, # Optional. Schema version of the content. Can be used to distinguish between different flow based on the schema version
        ///     icon: string, # Optional. the icon identifier. this id can later be fetched from the solution template
        ///     threatAnalysisTactics: [string], # Optional. the tactics the resource covers
        ///     threatAnalysisTechniques: [string], # Optional. the techniques the resource covers, these have to be aligned with the tactics being used
        ///     previewImages: [string], # Optional. preview image file names. These will be taken from the solution artifacts
        ///     previewImagesDark: [string], # Optional. preview image file names. These will be taken from the solution artifacts. used for dark theme support
        ///   }, # Optional. Metadata properties
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UpdateAsync(string resourceGroupName, string workspaceName, string metadataName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(workspaceName, nameof(workspaceName));
            Argument.AssertNotNullOrEmpty(metadataName, nameof(metadataName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("MetadataClient.Update");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateRequest(resourceGroupName, workspaceName, metadataName, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update an existing Metadata. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="workspaceName"> The name of the workspace. </param>
        /// <param name="metadataName"> The Metadata name. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/>, <paramref name="metadataName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="workspaceName"/> or <paramref name="metadataName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>MetadataPatch</c>:
        /// <code>{
        ///   etag: string, # Optional. Etag of the azure resource
        ///   id: string, # Optional. Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ///   name: string, # Optional. The name of the resource
        ///   type: string, # Optional. The type of the resource. E.g. &quot;Microsoft.Compute/virtualMachines&quot; or &quot;Microsoft.Storage/storageAccounts&quot;
        ///   systemData: {
        ///     createdBy: string, # Optional. The identity that created the resource.
        ///     createdByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that created the resource.
        ///     createdAt: string (ISO 8601 Format), # Optional. The timestamp of resource creation (UTC).
        ///     lastModifiedBy: string, # Optional. The identity that last modified the resource.
        ///     lastModifiedByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that last modified the resource.
        ///     lastModifiedAt: string (ISO 8601 Format), # Optional. The timestamp of resource last modification (UTC)
        ///   }, # Optional. Azure Resource Manager metadata containing createdBy and modifiedBy information.
        ///   properties: {
        ///     contentId: string, # Optional. Static ID for the content.  Used to identify dependencies and content from solutions or community.  Hard-coded/static for out of the box content and solutions. Dynamic for user-created.  This is the resource name
        ///     parentId: string, # Optional. Full parent resource ID of the content item the metadata is for.  This is the full resource ID including the scope (subscription and resource group)
        ///     version: string, # Optional. Version of the content.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM template best practices.  Can also be any string, but then we cannot guarantee any version checks
        ///     kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Optional. The kind of content the metadata is for.
        ///     source: {
        ///       kind: &quot;LocalWorkspace&quot; | &quot;Community&quot; | &quot;Solution&quot; | &quot;SourceRepository&quot;, # Required. Source type of the content
        ///       name: string, # Optional. Name of the content source.  The repo name, solution name, LA workspace name etc.
        ///       sourceId: string, # Optional. ID of the content source.  The solution ID, workspace ID, etc
        ///     }, # Optional. Source of the content.  This is where/how it was created.
        ///     author: {
        ///       name: string, # Optional. Name of the author. Company or person.
        ///       email: string, # Optional. Email of author contact
        ///       link: string, # Optional. Link for author/vendor page
        ///     }, # Optional. The creator of the content item.
        ///     support: {
        ///       tier: &quot;Microsoft&quot; | &quot;Partner&quot; | &quot;Community&quot;, # Required. Type of support for content item
        ///       name: string, # Optional. Name of the support contact. Company or person.
        ///       email: string, # Optional. Email of support contact
        ///       link: string, # Optional. Link for support help, like to support page to open a ticket etc.
        ///     }, # Optional. Support information for the metadata - type, name, contact information
        ///     dependencies: {
        ///       contentId: string, # Optional. Id of the content item we depend on
        ///       kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Optional. Type of the content item we depend on
        ///       version: string, # Optional. Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        ///       name: string, # Optional. Name of the content item
        ///       operator: &quot;AND&quot; | &quot;OR&quot;, # Optional. Operator used for list of dependencies in criteria array.
        ///       criteria: [MetadataDependencies], # Optional. This is the list of dependencies we must fulfill, according to the AND/OR operator
        ///     }, # Optional. Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex formats.
        ///     categories: {
        ///       domains: [string], # Optional. domain for the solution content item
        ///       verticals: [string], # Optional. Industry verticals for the solution content item
        ///     }, # Optional. Categories for the solution content item
        ///     providers: [string], # Optional. Providers for the solution content item
        ///     firstPublishDate: FirstPublishDate, # Optional. first publish date solution content item
        ///     lastPublishDate: LastPublishDate, # Optional. last publish date for the solution content item
        ///     customVersion: string, # Optional. The custom version of the content. A optional free text
        ///     contentSchemaVersion: string, # Optional. Schema version of the content. Can be used to distinguish between different flow based on the schema version
        ///     icon: string, # Optional. the icon identifier. this id can later be fetched from the solution template
        ///     threatAnalysisTactics: [string], # Optional. the tactics the resource covers
        ///     threatAnalysisTechniques: [string], # Optional. the techniques the resource covers, these have to be aligned with the tactics being used
        ///     previewImages: [string], # Optional. preview image file names. These will be taken from the solution artifacts
        ///     previewImagesDark: [string], # Optional. preview image file names. These will be taken from the solution artifacts. used for dark theme support
        ///   }, # Optional. Metadata patch request body
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>MetadataModel</c>:
        /// <code>{
        ///   etag: string, # Optional. Etag of the azure resource
        ///   id: string, # Optional. Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ///   name: string, # Optional. The name of the resource
        ///   type: string, # Optional. The type of the resource. E.g. &quot;Microsoft.Compute/virtualMachines&quot; or &quot;Microsoft.Storage/storageAccounts&quot;
        ///   systemData: {
        ///     createdBy: string, # Optional. The identity that created the resource.
        ///     createdByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that created the resource.
        ///     createdAt: string (ISO 8601 Format), # Optional. The timestamp of resource creation (UTC).
        ///     lastModifiedBy: string, # Optional. The identity that last modified the resource.
        ///     lastModifiedByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that last modified the resource.
        ///     lastModifiedAt: string (ISO 8601 Format), # Optional. The timestamp of resource last modification (UTC)
        ///   }, # Optional. Azure Resource Manager metadata containing createdBy and modifiedBy information.
        ///   properties: {
        ///     contentId: string, # Optional. Static ID for the content.  Used to identify dependencies and content from solutions or community.  Hard-coded/static for out of the box content and solutions. Dynamic for user-created.  This is the resource name
        ///     parentId: string, # Required. Full parent resource ID of the content item the metadata is for.  This is the full resource ID including the scope (subscription and resource group)
        ///     version: string, # Optional. Version of the content.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM template best practices.  Can also be any string, but then we cannot guarantee any version checks
        ///     kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Required. The kind of content the metadata is for.
        ///     source: {
        ///       kind: &quot;LocalWorkspace&quot; | &quot;Community&quot; | &quot;Solution&quot; | &quot;SourceRepository&quot;, # Required. Source type of the content
        ///       name: string, # Optional. Name of the content source.  The repo name, solution name, LA workspace name etc.
        ///       sourceId: string, # Optional. ID of the content source.  The solution ID, workspace ID, etc
        ///     }, # Optional. Source of the content.  This is where/how it was created.
        ///     author: {
        ///       name: string, # Optional. Name of the author. Company or person.
        ///       email: string, # Optional. Email of author contact
        ///       link: string, # Optional. Link for author/vendor page
        ///     }, # Optional. The creator of the content item.
        ///     support: {
        ///       tier: &quot;Microsoft&quot; | &quot;Partner&quot; | &quot;Community&quot;, # Required. Type of support for content item
        ///       name: string, # Optional. Name of the support contact. Company or person.
        ///       email: string, # Optional. Email of support contact
        ///       link: string, # Optional. Link for support help, like to support page to open a ticket etc.
        ///     }, # Optional. Support information for the metadata - type, name, contact information
        ///     dependencies: {
        ///       contentId: string, # Optional. Id of the content item we depend on
        ///       kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Optional. Type of the content item we depend on
        ///       version: string, # Optional. Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        ///       name: string, # Optional. Name of the content item
        ///       operator: &quot;AND&quot; | &quot;OR&quot;, # Optional. Operator used for list of dependencies in criteria array.
        ///       criteria: [MetadataDependencies], # Optional. This is the list of dependencies we must fulfill, according to the AND/OR operator
        ///     }, # Optional. Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex formats.
        ///     categories: {
        ///       domains: [string], # Optional. domain for the solution content item
        ///       verticals: [string], # Optional. Industry verticals for the solution content item
        ///     }, # Optional. Categories for the solution content item
        ///     providers: [string], # Optional. Providers for the solution content item
        ///     firstPublishDate: FirstPublishDate, # Optional. first publish date solution content item
        ///     lastPublishDate: LastPublishDate, # Optional. last publish date for the solution content item
        ///     customVersion: string, # Optional. The custom version of the content. A optional free text
        ///     contentSchemaVersion: string, # Optional. Schema version of the content. Can be used to distinguish between different flow based on the schema version
        ///     icon: string, # Optional. the icon identifier. this id can later be fetched from the solution template
        ///     threatAnalysisTactics: [string], # Optional. the tactics the resource covers
        ///     threatAnalysisTechniques: [string], # Optional. the techniques the resource covers, these have to be aligned with the tactics being used
        ///     previewImages: [string], # Optional. preview image file names. These will be taken from the solution artifacts
        ///     previewImagesDark: [string], # Optional. preview image file names. These will be taken from the solution artifacts. used for dark theme support
        ///   }, # Optional. Metadata properties
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Update(string resourceGroupName, string workspaceName, string metadataName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(workspaceName, nameof(workspaceName));
            Argument.AssertNotNullOrEmpty(metadataName, nameof(metadataName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("MetadataClient.Update");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateRequest(resourceGroupName, workspaceName, metadataName, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List of all metadata. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="workspaceName"> The name of the workspace. </param>
        /// <param name="filter"> Filters the results, based on a Boolean condition. Optional. </param>
        /// <param name="orderby"> Sorts the results. Optional. </param>
        /// <param name="top"> Returns only the first n results. Optional. </param>
        /// <param name="skip"> Used to skip n elements in the OData query (offset). Returns a nextLink to the next page of results if there are any left. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/> or <paramref name="workspaceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/> or <paramref name="workspaceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>MetadataListValue</c>:
        /// <code>{
        ///   etag: string, # Optional. Etag of the azure resource
        ///   id: string, # Optional. Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ///   name: string, # Optional. The name of the resource
        ///   type: string, # Optional. The type of the resource. E.g. &quot;Microsoft.Compute/virtualMachines&quot; or &quot;Microsoft.Storage/storageAccounts&quot;
        ///   systemData: {
        ///     createdBy: string, # Optional. The identity that created the resource.
        ///     createdByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that created the resource.
        ///     createdAt: string (ISO 8601 Format), # Optional. The timestamp of resource creation (UTC).
        ///     lastModifiedBy: string, # Optional. The identity that last modified the resource.
        ///     lastModifiedByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that last modified the resource.
        ///     lastModifiedAt: string (ISO 8601 Format), # Optional. The timestamp of resource last modification (UTC)
        ///   }, # Optional. Azure Resource Manager metadata containing createdBy and modifiedBy information.
        ///   properties: {
        ///     contentId: string, # Optional. Static ID for the content.  Used to identify dependencies and content from solutions or community.  Hard-coded/static for out of the box content and solutions. Dynamic for user-created.  This is the resource name
        ///     parentId: string, # Required. Full parent resource ID of the content item the metadata is for.  This is the full resource ID including the scope (subscription and resource group)
        ///     version: string, # Optional. Version of the content.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM template best practices.  Can also be any string, but then we cannot guarantee any version checks
        ///     kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Required. The kind of content the metadata is for.
        ///     source: {
        ///       kind: &quot;LocalWorkspace&quot; | &quot;Community&quot; | &quot;Solution&quot; | &quot;SourceRepository&quot;, # Required. Source type of the content
        ///       name: string, # Optional. Name of the content source.  The repo name, solution name, LA workspace name etc.
        ///       sourceId: string, # Optional. ID of the content source.  The solution ID, workspace ID, etc
        ///     }, # Optional. Source of the content.  This is where/how it was created.
        ///     author: {
        ///       name: string, # Optional. Name of the author. Company or person.
        ///       email: string, # Optional. Email of author contact
        ///       link: string, # Optional. Link for author/vendor page
        ///     }, # Optional. The creator of the content item.
        ///     support: {
        ///       tier: &quot;Microsoft&quot; | &quot;Partner&quot; | &quot;Community&quot;, # Required. Type of support for content item
        ///       name: string, # Optional. Name of the support contact. Company or person.
        ///       email: string, # Optional. Email of support contact
        ///       link: string, # Optional. Link for support help, like to support page to open a ticket etc.
        ///     }, # Optional. Support information for the metadata - type, name, contact information
        ///     dependencies: {
        ///       contentId: string, # Optional. Id of the content item we depend on
        ///       kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Optional. Type of the content item we depend on
        ///       version: string, # Optional. Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        ///       name: string, # Optional. Name of the content item
        ///       operator: &quot;AND&quot; | &quot;OR&quot;, # Optional. Operator used for list of dependencies in criteria array.
        ///       criteria: [MetadataDependencies], # Optional. This is the list of dependencies we must fulfill, according to the AND/OR operator
        ///     }, # Optional. Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex formats.
        ///     categories: {
        ///       domains: [string], # Optional. domain for the solution content item
        ///       verticals: [string], # Optional. Industry verticals for the solution content item
        ///     }, # Optional. Categories for the solution content item
        ///     providers: [string], # Optional. Providers for the solution content item
        ///     firstPublishDate: FirstPublishDate, # Optional. first publish date solution content item
        ///     lastPublishDate: LastPublishDate, # Optional. last publish date for the solution content item
        ///     customVersion: string, # Optional. The custom version of the content. A optional free text
        ///     contentSchemaVersion: string, # Optional. Schema version of the content. Can be used to distinguish between different flow based on the schema version
        ///     icon: string, # Optional. the icon identifier. this id can later be fetched from the solution template
        ///     threatAnalysisTactics: [string], # Optional. the tactics the resource covers
        ///     threatAnalysisTechniques: [string], # Optional. the techniques the resource covers, these have to be aligned with the tactics being used
        ///     previewImages: [string], # Optional. preview image file names. These will be taken from the solution artifacts
        ///     previewImagesDark: [string], # Optional. preview image file names. These will be taken from the solution artifacts. used for dark theme support
        ///   }, # Optional. Metadata properties
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetAllMetadataAsync(string resourceGroupName, string workspaceName, string filter = null, string orderby = null, int? top = null, int? skip = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(workspaceName, nameof(workspaceName));

            return GetAllMetadataImplementationAsync("MetadataClient.GetAllMetadata", resourceGroupName, workspaceName, filter, orderby, top, skip, context);
        }

        private AsyncPageable<BinaryData> GetAllMetadataImplementationAsync(string diagnosticsScopeName, string resourceGroupName, string workspaceName, string filter, string orderby, int? top, int? skip, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetAllMetadataRequest(resourceGroupName, workspaceName, filter, orderby, top, skip, context)
                        : CreateGetAllMetadataNextPageRequest(nextLink, resourceGroupName, workspaceName, filter, orderby, top, skip, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List of all metadata. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="workspaceName"> The name of the workspace. </param>
        /// <param name="filter"> Filters the results, based on a Boolean condition. Optional. </param>
        /// <param name="orderby"> Sorts the results. Optional. </param>
        /// <param name="top"> Returns only the first n results. Optional. </param>
        /// <param name="skip"> Used to skip n elements in the OData query (offset). Returns a nextLink to the next page of results if there are any left. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/> or <paramref name="workspaceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/> or <paramref name="workspaceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>MetadataListValue</c>:
        /// <code>{
        ///   etag: string, # Optional. Etag of the azure resource
        ///   id: string, # Optional. Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
        ///   name: string, # Optional. The name of the resource
        ///   type: string, # Optional. The type of the resource. E.g. &quot;Microsoft.Compute/virtualMachines&quot; or &quot;Microsoft.Storage/storageAccounts&quot;
        ///   systemData: {
        ///     createdBy: string, # Optional. The identity that created the resource.
        ///     createdByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that created the resource.
        ///     createdAt: string (ISO 8601 Format), # Optional. The timestamp of resource creation (UTC).
        ///     lastModifiedBy: string, # Optional. The identity that last modified the resource.
        ///     lastModifiedByType: &quot;User&quot; | &quot;Application&quot; | &quot;ManagedIdentity&quot; | &quot;Key&quot;, # Optional. The type of identity that last modified the resource.
        ///     lastModifiedAt: string (ISO 8601 Format), # Optional. The timestamp of resource last modification (UTC)
        ///   }, # Optional. Azure Resource Manager metadata containing createdBy and modifiedBy information.
        ///   properties: {
        ///     contentId: string, # Optional. Static ID for the content.  Used to identify dependencies and content from solutions or community.  Hard-coded/static for out of the box content and solutions. Dynamic for user-created.  This is the resource name
        ///     parentId: string, # Required. Full parent resource ID of the content item the metadata is for.  This is the full resource ID including the scope (subscription and resource group)
        ///     version: string, # Optional. Version of the content.  Default and recommended format is numeric (e.g. 1, 1.0, 1.0.0, 1.0.0.0), following ARM template best practices.  Can also be any string, but then we cannot guarantee any version checks
        ///     kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Required. The kind of content the metadata is for.
        ///     source: {
        ///       kind: &quot;LocalWorkspace&quot; | &quot;Community&quot; | &quot;Solution&quot; | &quot;SourceRepository&quot;, # Required. Source type of the content
        ///       name: string, # Optional. Name of the content source.  The repo name, solution name, LA workspace name etc.
        ///       sourceId: string, # Optional. ID of the content source.  The solution ID, workspace ID, etc
        ///     }, # Optional. Source of the content.  This is where/how it was created.
        ///     author: {
        ///       name: string, # Optional. Name of the author. Company or person.
        ///       email: string, # Optional. Email of author contact
        ///       link: string, # Optional. Link for author/vendor page
        ///     }, # Optional. The creator of the content item.
        ///     support: {
        ///       tier: &quot;Microsoft&quot; | &quot;Partner&quot; | &quot;Community&quot;, # Required. Type of support for content item
        ///       name: string, # Optional. Name of the support contact. Company or person.
        ///       email: string, # Optional. Email of support contact
        ///       link: string, # Optional. Link for support help, like to support page to open a ticket etc.
        ///     }, # Optional. Support information for the metadata - type, name, contact information
        ///     dependencies: {
        ///       contentId: string, # Optional. Id of the content item we depend on
        ///       kind: &quot;DataConnector&quot; | &quot;DataType&quot; | &quot;Workbook&quot; | &quot;WorkbookTemplate&quot; | &quot;Playbook&quot; | &quot;PlaybookTemplate&quot; | &quot;AnalyticsRuleTemplate&quot; | &quot;AnalyticsRule&quot; | &quot;HuntingQuery&quot; | &quot;InvestigationQuery&quot; | &quot;Parser&quot; | &quot;Watchlist&quot; | &quot;WatchlistTemplate&quot; | &quot;Solution&quot; | &quot;AzureFunction&quot; | &quot;LogicAppsCustomConnector&quot; | &quot;AutomationRule&quot;, # Optional. Type of the content item we depend on
        ///       version: string, # Optional. Version of the the content item we depend on.  Can be blank, * or missing to indicate any version fulfills the dependency.  If version does not match our defined numeric format then an exact match is required.
        ///       name: string, # Optional. Name of the content item
        ///       operator: &quot;AND&quot; | &quot;OR&quot;, # Optional. Operator used for list of dependencies in criteria array.
        ///       criteria: [MetadataDependencies], # Optional. This is the list of dependencies we must fulfill, according to the AND/OR operator
        ///     }, # Optional. Dependencies for the content item, what other content items it requires to work.  Can describe more complex dependencies using a recursive/nested structure. For a single dependency an id/kind/version can be supplied or operator/criteria for complex formats.
        ///     categories: {
        ///       domains: [string], # Optional. domain for the solution content item
        ///       verticals: [string], # Optional. Industry verticals for the solution content item
        ///     }, # Optional. Categories for the solution content item
        ///     providers: [string], # Optional. Providers for the solution content item
        ///     firstPublishDate: FirstPublishDate, # Optional. first publish date solution content item
        ///     lastPublishDate: LastPublishDate, # Optional. last publish date for the solution content item
        ///     customVersion: string, # Optional. The custom version of the content. A optional free text
        ///     contentSchemaVersion: string, # Optional. Schema version of the content. Can be used to distinguish between different flow based on the schema version
        ///     icon: string, # Optional. the icon identifier. this id can later be fetched from the solution template
        ///     threatAnalysisTactics: [string], # Optional. the tactics the resource covers
        ///     threatAnalysisTechniques: [string], # Optional. the techniques the resource covers, these have to be aligned with the tactics being used
        ///     previewImages: [string], # Optional. preview image file names. These will be taken from the solution artifacts
        ///     previewImagesDark: [string], # Optional. preview image file names. These will be taken from the solution artifacts. used for dark theme support
        ///   }, # Optional. Metadata properties
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetAllMetadata(string resourceGroupName, string workspaceName, string filter = null, string orderby = null, int? top = null, int? skip = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(workspaceName, nameof(workspaceName));

            return GetAllMetadataImplementation("MetadataClient.GetAllMetadata", resourceGroupName, workspaceName, filter, orderby, top, skip, context);
        }

        private Pageable<BinaryData> GetAllMetadataImplementation(string diagnosticsScopeName, string resourceGroupName, string workspaceName, string filter, string orderby, int? top, int? skip, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetAllMetadataRequest(resourceGroupName, workspaceName, filter, orderby, top, skip, context)
                        : CreateGetAllMetadataNextPageRequest(nextLink, resourceGroupName, workspaceName, filter, orderby, top, skip, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        internal HttpMessage CreateGetAllMetadataRequest(string resourceGroupName, string workspaceName, string filter, string orderby, int? top, int? skip, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(_subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.OperationalInsights/workspaces/", false);
            uri.AppendPath(workspaceName, true);
            uri.AppendPath("/providers/Microsoft.SecurityInsights/metadata", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (orderby != null)
            {
                uri.AppendQuery("$orderby", orderby, true);
            }
            if (top != null)
            {
                uri.AppendQuery("$top", top.Value, true);
            }
            if (skip != null)
            {
                uri.AppendQuery("$skip", skip.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMetadataRequest(string resourceGroupName, string workspaceName, string metadataName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(_subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.OperationalInsights/workspaces/", false);
            uri.AppendPath(workspaceName, true);
            uri.AppendPath("/providers/Microsoft.SecurityInsights/metadata/", false);
            uri.AppendPath(metadataName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteRequest(string resourceGroupName, string workspaceName, string metadataName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(_subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.OperationalInsights/workspaces/", false);
            uri.AppendPath(workspaceName, true);
            uri.AppendPath("/providers/Microsoft.SecurityInsights/metadata/", false);
            uri.AppendPath(metadataName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateRequest(string resourceGroupName, string workspaceName, string metadataName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(_subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.OperationalInsights/workspaces/", false);
            uri.AppendPath(workspaceName, true);
            uri.AppendPath("/providers/Microsoft.SecurityInsights/metadata/", false);
            uri.AppendPath(metadataName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateUpdateRequest(string resourceGroupName, string workspaceName, string metadataName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(_subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.OperationalInsights/workspaces/", false);
            uri.AppendPath(workspaceName, true);
            uri.AppendPath("/providers/Microsoft.SecurityInsights/metadata/", false);
            uri.AppendPath(metadataName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetAllMetadataNextPageRequest(string nextLink, string resourceGroupName, string workspaceName, string filter, string orderby, int? top, int? skip, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier200204;
        private static ResponseClassifier ResponseClassifier200204 => _responseClassifier200204 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 204 });
        private static ResponseClassifier _responseClassifier200201;
        private static ResponseClassifier ResponseClassifier200201 => _responseClassifier200201 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 201 });
    }
}
